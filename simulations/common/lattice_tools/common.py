import numpy as np


def mag(vec):
    keepdims = len(vec.shape) > 1
    return np.sqrt(np.sum(vec ** 2, axis=0, keepdims=keepdims))


def norm(vec):
    return vec / mag(vec)


def get_basis_rotation_matrix(basis):
    basis_map = np.zeros((3, 3))
    basis_map[:, 0] = norm(basis[:, 0])
    basis_map[:, 2] = norm(np.cross(basis[:, 0], basis[:, 1]))
    basis_map[:, 1] = norm(np.cross(basis_map[:, 2], basis_map[:, 0]))
    inv_map = np.linalg.inv(basis_map)
    return inv_map


def rotate_basis(basis):
    """
    Rotates the basis vectors so that the first vector lays parallel to the x
    axis, the second column lays in the x-y plane and the cross product of the first
    and second vector is parallel to the z axis. This function is useful to ensure that
    the plane generated by vectors 1&2 is the x-y plane

    Parameters
    ----------
    basis
        Some 3x3 basis matrix of column vectors

    Returns
    -------
        A 3x3 basis matrix of column vectors with the above properties
    """
    basis_rotation = get_basis_rotation_matrix(basis)
    return basis_rotation.dot(basis)


def get_lattice_points(n, k, l):
    """
    Generates the integer co-ordinates of a substrate with n x k x l lattice points

    Parameters
    ----------
    n
        The number of lattice points in the first basis vector direction
    k
        The number of lattice points in the second basis vector direction
    l
        The number of lattice points in the third basis vector direction

    Returns
    -------
        A 3 x n x k x l matrix, one entry for each lattice point
    """
    return np.asarray(np.meshgrid(np.arange(n), np.arange(k), np.arange(l), indexing='ij'))


def change_basis(new_basis, points):
    """
    Returns a 3 x n x k x l matrix of the cartesian co-ordinates of each lattice point
    in the substrate

    Parameters
    ----------
    new_basis
        The new basis as a 3x3 column matrix
    points
        The points in the old basis. First axis must be the co-ordinate axis (size 3).
        Shape 3 x ....

    Returns
    -------
        A 3 x ... matrix, of each point in the new basis.
    """
    return np.tensordot(new_basis, points, axes=(1, 0))


def get_reciprocal_basis(basis):
    V = basis[:, 0].dot(np.cross(basis[:, 1], basis[:, 2]))
    reciprocal_basis = 2 * np.pi / V * np.asarray([
        np.cross(basis[:, 1], basis[:, 2]),
        np.cross(basis[:, 2], basis[:, 0]),
        np.cross(basis[:, 0], basis[:, 1])
    ]).T
    return reciprocal_basis


def in_plane_rot90(vec):
    return np.asarray([-vec[1], vec[0], vec[2]])


def get_in_plane_reciprocal_basis(basis):
    return 2 * np.pi * np.asarray([
        in_plane_rot90(-basis[:, 1]),
        in_plane_rot90(basis[:, 0])
    ]).T / basis[:, 0].dot(in_plane_rot90(basis[:, 1]))
